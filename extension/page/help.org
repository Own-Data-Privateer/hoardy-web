#+MACRO: shortcut @@html:<span data-macro-shortcut="$1">bound to <code>manifest.commands.$1</code></span>@@

#+BEGIN_EXPORT html
<div name="less">
#+END_EXPORT
* How to read this document
It is highly recommended you view this page by clicking the "Help" button in the extension's own UI.
Doing that will make this page interactive: the settings popup will be displayed on the right on this page and hovering over or clicking on any links pointing to =popup.html= will highlight those elements in the popup.

See [[../../doc/gallery.md][screenshots]] if you want to see how it will look.

You can still read this page outside of the extension's UI, but be prepared for all links pointing to =popup.html= to be useless.
#+BEGIN_EXPORT html
</div>
#+END_EXPORT
* What?
=pWebArc= (Personal Private Passive Web Archive) is a browser extension that passively captures, collects, and archives dumps of HTTP requests and responses to your own private archiving server (like [[https://github.com/Own-Data-Privateer/pwebarc/tree/master/dumb_server/][the dumb archiving server]], also [[https://oxij.org/software/pwebarc/tree/master/dumb_server/][there]]) as you browse the web.
** Glossary
- A /reqres/ (/REQuest/ + /RESponse/) is a pWebArc-internal object containing captured information about an HTTP request and its response, including their headers and data, and some meta-information (whether it originates from an extension, =tabId= it originates from, its state, etc).
* General operation
** State Diagram
Reqres change their internal states according to the following state diagram (which is explained below):

#+BEGIN_SRC
(start) -> (request sent) -> (nIO) -> (headers received) -> (nIO) --> (body recived)
   |                           |                              |             |
   |                           v                              v             v
   |                     (no_response)                   (incomplete)   (complete)
   |                           |                              |             |
   |                           \                              |             |
   |\---> (canceled) ----\      \                             |             |
   |                      \      \                            \             |
   |\-> (incomplete_fc) ---\      \                            \            v
   |                        >------>---------------------------->-----> (finished)
   |\--> (complete_fc) ----/                                             /  |
   |                      /                                       /-----/   |
   \----> (snapshot) ----/         /--------------- (picked) <---/          v
                                   |                   |                (dropped)
                                   v                   v                 /  |
       (archived) <- (sIO) <- (collected) <------- (in_limbo) <---------/   |
                       |           ^                   |                    |
                       |           |                   |                    |
                /------/           \-----\             \--> (discarded) <---/
                |                        |
                \-> (failed to archive) -/
#+END_SRC
** Step 1: Tracking
pWebArc attaches to your browser's runtime and tracks progress of HTTP requests and their responses, capturing both their request and response headers and data at appropriate times in the browser's request and response processing pipeline.

Whether pWebArc will track a given request depends on the "Track new reqres" toggles (or checkboxes, if you are using a browser without support for the needed CSS) in the settings popup, e.g:

- [[./popup.html#div-config.collecting][this toggle]] allows you to disable tracking of newly spawned HTTP requests globally, thus essentially disabling pWebArc,
- [[./popup.html#div-tabconfig.collecting][this one]] controls whether pWebArc will track new reqres originating from the currently active tab,
- [[./popup.html#div-tabconfig.children.collecting][this one]] controls whether it will track new reqres originating from new tabs opened from the currently active tab (aka "children tabs", e.g. via middle mouse click, context menu, etc),
- while [[./popup.html#div-config.root.collecting][this one]] controls whether it will track new reqres originating from new tabs opened via browser's "New Tab" browser action (i.e. the plus sign in the tab bar, =Control+T=, menu item, etc),
- and so forth for the others (press "?" symbols to see a tooltip explaining what each of them does).

Disabling any of these toggles does not stop tracking of already initiated requests, it only stops new requests controlled by that toggle from being tracked.
*** The networking states of the State Diagram
As shown on the above diagram, a new reqres proceeds through the following networking states:

- =start=: the starting state;
- =request sent=, (response) =headers received=, (response) =body recived=: these are the normal HTTP request stages (stages of [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/webRequest][=webRequest= sub-API of =WebExtensions= API]]);
- =nIO=: normal network IO performed by the browser in between HTTP request stages;
- =canceled=: request was canceled before it was sent (by you, by the browser itself --- e.g. when rewriting an =http://= URL to an =https://= URL in HTTPS-only mode ---, by an ad-blocking extension like "uBlock Origin", etc);
  =unsent= would have probably been a better name for this, but all browsers call it =canceled=, so pWebArc follows;
- =no_response=: request was sent, but no response was received (connection to the server was rejected, you canceled it manually via the "Stop" button before it got a response, the server decided to ignore the request completely, network timeout was reached, etc);
- =incomplete=: request was sent, response headers were received, but then the loading was interrupted before all of the response body was received;
- =incomplete_fc=: only on Firefox-based browsers: the browser loaded the response data of this reqres directly from its cache, but did not give it to pWebArc; this is just how Firefox handles things sometimes (usually, for images); this is a separate state, because usually this means this URL was successfully archived before (if it was not, reload the page with =Control+F5=);
- =complete=: request was completed successfully;
- =complete_fc=: request was completed successfully from browser's cache;
- =snapshot=: this reqres was produced by taking a DOM (Document Object Model) snapshot (using one of the [[./popup.html#snapshotTab][appropriate]]-[[./popup.html#snapshotAll][buttons]] in the popup), i.e. it was produced by capturing a raw HTML/XML of the current state of the tab/frame, not by capturing a network request;
- =finished=: the terminal state of this step, no new events for this reqres will come from the browser.

In principle, at reaching =finished= state the reqres can be serialized and saved to disk, but pWebArc provides more states and UI for convenience.
*** Glossary
- [[./popup.html#div-tabstats.in_flight][An /in-flight reqres/]] ([[./popup.html#div-stats.in_flight][globally]]) is a reqres that did not reach the =finished= state yet, in the UI such reqres will be shown to be in =in_flight= state.
  If some reqres get stuck in one of the =in_flight= states, the UI has buttons ([[./popup.html#stopAllTabInFlight][this]] and [[./popup.html#stopAllInFlight][this]] in the popup) to force them out of the current state as if an error occurred.
- A /finished reqres/ is a reqres that reached the =finished= state.
- /Final networking state/ is the last state a reqres had before it =finished=: i.e. =complete=, =incomplete=, =canceled=, etc.
** Step 2: Classification
:PROPERTIES:
:CUSTOM_ID: classification
:END:

On reaching the =finished= state, pWebArc performs reqres classification controlled by [[./popup.html#pick-options]["Pick reqres for archival when they finish"]] and [[./popup.html#problematic-options]["Mark reqres as problematic when they finish" ]] settings.
The [[./popup.html#pick-options][former]] set decides whether the reqres in question should be =picked= or =dropped=, which influences the actions pWebArc will perform in the next step.
The [[./popup.html#problematic-options][latter]] set decides if the reqres in question should be marked as =problematic=.
*** Problematic reqres
:PROPERTIES:
:CUSTOM_ID: problematic
:END:

The =problematic= reqres status is a flag (NOT a state) that does not influence archival or any actions discussed in the latter steps.
It exists because browsers provide no indication when some parts of the page failed to load properly --- they expect you to actually look at the page with your eyes to notice something looking broken (and reload it manually) instead --- which is counterproductive when you want to be sure that the whole page with all its resources was archived.

After all, parts of a dynamically loaded page might simply silently fail to be rendered by associated JavaScript because some of the HTTP requests that JavaScript did in background failed, or, on a static web page, layout and CSS might have made some of the incompletely loaded parts of the page invisible (by design or by accident).

So, to provide an indicator for such cases, pWebArc keeps the log of =problematic= reqres and displays the number of elements in the log in its toolbar button's badge.

By default, HTTP requests that failed to get a response, those that have incomplete response bodies, and those for which the browser reported potentially /problematic errors/ but then pWebArc =picked= them anyway, will be marked as =problematic=.

/Problematic errors/ are errors like

- "fetching of this request's data was aborted because this whole request was aborted, for instance, because the JavaScript making it decided to cancel it as no longer relevant when you moved your mouse cursor away from an interactive video thumbnail it was needed for",
- and similar things that probably imply some part of the page was left unfetched,

but NOT errors like

- "fetching of this request's data was aborted because it was redirected by the server",
- "the browser decided against rendering of this data",
- and similar errors where the data was properly fetched.

(In principle, pWebArc could have been designed to never record the errors of the latter category in the first place, thus simplifying the above bit, but pWebArc is designed to follow the philosophy or "collect everything as browser gives it, as raw as possible, do all the post-processing logic separately, allow for no logic at all, if the user asks for it".)

The raw error strings reported by the browser for each reqres can be seen in the [[./popup.html#showState][recent reqres history log]].

If [[./popup.html#div-config.problematicNotify][this option]] is enabled pWebArc will generate a desktop notification each time a new /problematic reqres/ get produced.
If you don't care about the /problematic/ flag and it annoys you, you should disable that option, not options under [[./popup.html#problematic-options]["Mark reqres as problematic when they finish" settings]].
*** Glossary
- [[./popup.html#div-tabstats.picked][A /picked reqres/]] ([[./popup.html#div-stats.picked][globally]]) is a /finished reqres/ that satisfied the conditions controlled by [[./popup.html#pick-options]["Pick reqres for archival when they finish" settings]] on entering the =finished= state.

- [[./popup.html#div-tabstats.dropped][A /dropped reqres/]] ([[./popup.html#div-stats.dropped][globally]]) is a /finished reqres/ that did /NOT/ satisfy the conditions controlled by [[./popup.html#pick-options]["Pick reqres for archival when they finish" settings]] on entering the =finished= state.

- [[./popup.html#div-tabstats.problematic][A /problematic reqres/]] ([[./popup.html#div-stats.problematic][globally]]) is a /finished reqres/ that satisfies the conditions set by [[./popup.html#problematic-options]["Mark reqres as problematic when they finish" settings]].
** Step 3: Collection, Discarding, and Limbo
Normally, /picked reqres/ proceed to the =collected= state, which queues them for archival.
Similarly, /dropped reqres/ proceed to being =discarded= from memory.
*** Limbo mode
:PROPERTIES:
:CUSTOM_ID: limbo
:END:

However, sometimes you might want to actually look at a web page before deciding if you want to archive it or not.
The naive way to do it would be to load a page with [[./popup.html#div-tabconfig.collecting][capture]] disabled first, look at it, and then, if you want to save it, enable [[./popup.html#div-tabconfig.collecting][it]], and reload the page with =Control+F5= again.

Obviously, this is both annoying and will force you to fetch everything twice.

Which is why "limbo mode" exists.
With one of the "limbo mode" options enabled, pWebArc will instead capture everything as normal but then, instead of sending the reqres in question to =collected= or =discarded= states immediately, it will put them into =in_limbo= state where they would linger until you /collect/ it or /discard/ them manually by pressing the [[./popup.html#div-tabstats.in_limbo][appropriate]]-[[./popup.html#div-stats.in_limbo][buttons]], or until [[./popup.html#closed-auto-options]["Automatic actions for recently closed tabs" options]] make a decision semi-automatically for you.

A /picked reqres/ will be put into =in_limbo= when [[./popup.html#div-tabconfig.limbo]["Pick into limbo" setting]] is enabled in the currently active tab or when [[./popup.html#div-tabconfig.children.limbo][one]]-[[./popup.html#div-config.root.limbo][of]]-[[./popup.html#div-config.background.limbo][the]]-[[./popup.html#div-config.extension.limbo][other]] settings is enabled for other reqres sources.

Similarly, for a /dropped reqres/ will be put into =in_limbo= when [[./popup.html#div-tabconfig.negLimbo]["Drop into limbo" setting]] is enabled in the currently active tab or when [[./popup.html#div-tabconfig.children.negLimbo][one]]-[[./popup.html#div-config.root.negLimbo][of]]-[[./popup.html#div-config.background.negLimbo][the]]-[[./popup.html#div-config.extension.negLimbo][other]] settings is enabled for other reqres sources.
(This latter option mainly exists for debugging.)

If [[./popup.html#div-config.limboNotify][this option]] is enabled and there are more than [[./popup.html#div-config.limboMaxNumber][this number]] reqres =in_limbo= or the total size of all dumps =in_limbo= is more than [[./popup.html#div-config.limboMaxSize][this size]] (in MiB), pWebArc will complain to remind you to /collect/ or /discard/ some of them so that your browser does not waste much memory and so that you won't loose too much data if something crashes.
*** Glossary
- [[./popup.html#div-tabstats.collected][A /collected reqres/]] ([[./popup.html#div-stats.collected][globally]]) is a reqres that was (either automatically or manually) sent to the =collected= state.
- [[./popup.html#div-tabstats.discarded][A /discarded reqres/]] ([[./popup.html#div-stats.discarded][globally]]) is a reqres that was (either automatically or manually) sent to the =discarded=.
- [[./popup.html#div-tabstats.in_limbo][An /in-limbo reqres/]] ([[./popup.html#div-stats.in_limbo][globally]]) is a reqres that is being held =in_limbo= until you manually /collect/ or /discard/ it.
** Step 3.5: Logging
On entering =collected= or =discarded= state, metadata of each reqres is copied into the recent reqres [[./popup.html#showTabState][history]]-[[./popup.html#showState][log]] and is kept there until the size of the log reaches [[./popup.html#div-config.history][this many elements]], at which point the older elements of the log start being elided automatically.

You can also ask pWebArc to forget some history manually by pressing [[./popup.html#forgetTabHistory][this button]] to forget history of reqres generated by the currently active tab or [[./popup.html#forgetHistory][that button]] to forget all history.

Note, however, that /problematic reqres/ will not get automatically elided from the log, nor forgotten by using the above buttons.
To forget about them, you will have to unset the /problematic/ flag on the respective reqres via [[./popup.html#unmarkAllTabProblematic][this button]], or [[./popup.html#unmarkAllProblematic][that button]], or use similar buttons in the [[./popup.html#showState][log]].
** Step 4: Archival
When [[./popup.html#div-config.archive]["Archive collected reqres" toggle]] is enabled, pWebArc will pop =collected= reqres from the archival queue one by one, serialize them into CBOR-formatted dumps, and then push those dumps to the archiving server at [[./popup.html#div-config.submitHTTPURLBase]["Archive collected reqres to URL" setting]] by turning each reqres into a POST HTTP request with the dump of the reqres as request body (which is denoted by =srvIO= state on the diagram).
*** Buckets
:PROPERTIES:
:CUSTOM_ID: bucket
:END:

Sometimes you might want to split your archivals into separate /buckets/ to simplify future hoarding and sharing of collected archives.
E.g., say, by default you might want to put everything into the "default" bucket, but then you might want to put reqres produced by a select tab where you just logged in into you personal account into the "private" bucket instead.

To implement this, for each reqres in the archival queue, pWebArc computes a =bucket= parameter from the appropriate "Bucket" setting, e.g.

- [[./popup.html#div-tabconfig.bucket][this one]] will be used for requests originating from the currently active tab,
- [[./popup.html#div-tabconfig.children.bucket][this one]] will be used for requests originating from new child tabs opened from the currently active tab (e.g. via middle mouse click, context menu, etc),
- while [[./popup.html#div-config.root.bucket][this one]] will be used for new tabs opened via browser's "New Tab" browser action (i.e. the plus sign in the tab bar, =Control+T=, menu item, etc),
- and so forth for the others (press "?" symbols to see a tooltip explaining what each of them does).

Evaluation of the =bucket= parameter is done just before each archival attempt, so if the queue is not yet empty, and you disable [[./popup.html#div-config.archive]["Archive =collected= reqres"]], edit some of the "Bucket" settings, and enable [[./popup.html#div-config.archive][it]] again, pWebArc will start using the new setting immediately.

When submitting to an HTTP server, pWebArc will specify =bucket= as a query parameter (named "profile", for historical reasons) to each HTTP POST request.
*** Failures
If [[./popup.html#div-config.archiveFailedNotify][this option]] is enabled and some reqres failed to be archived, a new desktop notification will be generated.
If [[./popup.html#div-config.archiveDoneNotify][this option]] is enabled, a new desktop notification will be generated when the archival queue gets empty the very first time or after any failures.
*** Glossary
- [[./popup.html#div-stats.queued][A /queued reqres/]] is a =collected= reqres still =queued= for archival.

Displayed on the [[./popup.html#div-stats.submittedHTTP][Pushed/Failed reqres]] line:

- [[./popup.html#stats.submittedHTTP][A /submitted reqres/]] is a reqres that was successfully =submitted= to the archiving server and thus was discarded from memory.
- /An archived reqres/ is either /submitted/ or /saved/ reqres.
- [[./popup.html#stats.failed][A /failed to archive reqres/]] is a reqres that =failed= to be archived to the archiving server.
  Archivals of reqres' that failed because of networking issues will be retried automatically every 60 seconds.
  Archivals of reqres' rejected by the archiving server will not be retried automatically as those usually happen when there is no space left on the device the server is archiving to.
  You can retry all failed archivals by pressing [[./popup.html#retryFailed][this button]].
* Shortcuts
pWebArc provides a bunch of keyboard and context menu shortcuts to allow using it in more efficient ways.

- On Firefox-based browsers, you can see and edit all keyboard shortcuts via "Add-ons and themes" (=about:addons=) -> the gear icon -> Manage Extension Shortcuts.
- On Chromium-based browsers, you can see and edit all keyboard shortcuts via the menu -> "Extensions" -> "Manage Extensions" (=chrome://extensions/=) -> "Keyboard shortcuts" (on the left).
** Keyboard shortcuts
pWebArc provides shortcuts to:

- open [[./popup.html#showState][the "Internal State and Logs" page]], {{{shortcut(showState)}}};
- open the "Internal State and Logs" page, scrolled to the end of the log, {{{shortcut(showLog)}}};
- open [[./popup.html#showTabState][the "Internal State and Logs" page]] narrowed to the currently active tab's data, {{{shortcut(showTabState)}}};
- open the "Internal State and Logs" page narrowed to the currently active tab's data, scrolled to the end of the log, {{{shortcut(showTabLog)}}};
- toggle [[./popup.html#div-tabconfig.collecting][tracking of newly spawned HTTP requests in the currently active tab]] {{{shortcut(toggleTabConfigTracking)}}};
- toggle [[./popup.html#div-tabconfig.children.collecting][tracking of newly spawned HTTP requests currently active tab's children]] {{{shortcut(toggleTabConfigChildrenTracking)}}};
- toggle [[./popup.html#div-tabconfig.limbo][limbo mode in the currently active tab]], {{{shortcut(toggleTabConfigLimbo)}}};
- toggle [[./popup.html#div-tabconfig.children.limbo][limbo mode in currently active tab's children]], {{{shortcut(toggleTabConfigChildrenLimbo)}}};
- [[./popup.html#unmarkAllProblematic][unmark all problematic reqres]], {{{shortcut(unmarkAllProblematic)}}};
- [[./popup.html#unmarkAllTabProblematic][unmark all current tab's problematic reqres]], {{{shortcut(unmarkAllTabProblematic)}}};
- [[./popup.html#collectAllInLimbo][collect all reqres from limbo]], {{{shortcut(collectAllInLimbo)}}};
- [[./popup.html#collectAllTabInLimbo][collect all reqres from limbo for the currently active tab]], {{{shortcut(collectAllTabInLimbo)}}};
- [[./popup.html#discardAllInLimbo][discard all reqres from limbo]], {{{shortcut(discardAllInLimbo)}}};
- [[./popup.html#discardAllTabInLimbo][discard all reqres from limbo for the currently active tab]], {{{shortcut(discardAllTabInLimbo)}}};
- [[./popup.html#snapshotAll][take DOM snapshot of all tabs]] for which [[./popup.html#div-tabconfig.collecting]["Track newly generated requests" setting]] is enabled, {{{shortcut(snapshotAll)}}};
- [[./popup.html#snapshotTab][take DOM snapshot of the currently active tab]], {{{shortcut(snapshotTab)}}}.
** Context menu actions
pWebArc provides context menu actions to:

- open a given link in a new tab with currently active tab's [[./popup.html#div-tabconfig.children.collecting][tracking in children tabs setting]] negated.
  I.e.,

  - right-mouse clicking while pointing at a link and
  - selecting "Open Link in New Tracked/Untracked Tab" from "pWebArc" sub-menu,

  is equivalent to

  - toggling [[./popup.html#div-tabconfig.children.collecting][this]],
  - middle-mouse clicking a link,
  - toggling [[./popup.html#div-tabconfig.children.collecting][this]] again.

- do the same thing, but opening it in a new window.
* Quirks and Bugs
:PROPERTIES:
:CUSTOM_ID: bugs
:END:
** Known extension issues
- At the moment, reqres =in_limbo= and =collected= reqres in the archival queue are only stored in memory, so if you close the browser or reload the extension before all the queued reqres finish archiving, or if you forget about some reqres =in_limbo=, you will lose some data.

  This is not an issue under normal conditions, as limbo is disabled by default and archiving a reqres takes milliseconds, meaning that the queue will stay empty almost all of the time.
  But this is technically a bug that might get fixed later.

- When the extension is (re-)loaded, all tabs inherit the values of [[./popup.html#root-tab-options][these settings]].

- pWebArc does not implement collection of WebSockets data on any of the supported browsers.

  (Firefox does not support it.
  Chromium does support it, in theory, but I have not tried using that API, so I have no idea how well it works.)

  This is low-priority issue since you can simply take a DOM [[./popup.html#snapshotTab][snapshot]] instead of capturing and later replaying WebSocket messages to in-page JavaScript.
  Also, capturing and archiving a DOM snapshot will free you from needing to run any JavaScript at all when you decide to return to view the archived page later, which is nice.

- On Chromium, response data of background requests and requests made by other extensions does not get collected, since there's no tab to attach a debugger to, and I have not figured out how to attach debugger to other things yet.
** Relevant issues of Firefox, Tor Browser, LibreWolf, etc
:PROPERTIES:
:CUSTOM_ID: firefox-bugs
:END:

- On Firefox-based browsers, without the [[https://github.com/Own-Data-Privateer/pwebarc/tree/master/firefox/][patch]] (also [[https://oxij.org/software/pwebarc/tree/master/firefox/][there]]), the browser only supplies =formData= to =webRequest.onBeforeRequest= handlers, thus making impossible to recover the actual request body for a POST request.

  pWebArc will mark such requests as having a "partial request body" and try its best to recover the data from =formData= structure, but if a POST request was uploading files, they won't be recoverable from =formData= (in fact, it is not even possible to tell if there were any files attached there), and so your archived request data will be incomplete even after pWebArc did its best.

  Disabling [[./popup.html#div-config.archivePartialRequest][this toggle]] will disable archiving of such broken requests.
  This is not recommended, however, as archiving some data is usually better than archiving none.

  With the above patch applied, small POST requests will be archived completely and correctly.
  POST requests that upload large files and only those will be marked as having a "partial request body".

- =If-Modified-Since= and =If-None-Match= headers never get archived, because the browser never supplies them to the extensions. Thus, you can get "304 Not Modified" reqres response to a seemingly normal "GET" request.

- Reqres of already cached media files (images, audio, video, except for svg and favicons) will end in =incomplete= state because =webRequest.filterResponseData= API does not provide response bodies for such requests.
  [[./popup.html#div-config.archiveIncompleteResponse][This toggle]] controls if such reqres should be =picked=.

  By default, pWebArc will =drop= them.
  Usually this is not a problem since such media will be archived on first (non-cached) access.
  But if you want to force everything on the page to be archived, you can reload the page without the cache with =Control+F5=.

- Firefox fails to run =onstop= method for =webRequest.filterResponseData= filter for the very first HTTP/2 request the browser makes after you start it, thus making the reqres of that request =incomplete=.
  If [[./popup.html#div-config.workaroundFirefoxFirstRequest][this option]] is enabled, pWebArc transparently works around this bug by redirecting the very first navigation request to =about:blank= and then reloading the tab with its original URL.

- Firefox-based browsers provide no API for archiving WebSockets data at the moment, unfortunately.
** Relevant issues of Chromium, Chrome, etc
:PROPERTIES:
:CUSTOM_ID: chromium-bugs
:END:

On Chromium-based browsers, there is no way to get HTTP response data without attaching Chromium's debugger to a tab from which a request originates from.
This makes things a bit tricky, for instance:

- With [[./popup.html#div-config.collecting][pWebArc]] and [[./popup.html#div-config.workaroundChromiumResetRootTab][this option]] enabled, new tabs will be reset to [[./popup.html#div-config.workaroundChromiumResetRootTabURL][this value]] (=about:blank= by default) because the default of =chrome://newtab/= does not allow attaching debugger to the tabs with =chrome:= URLs.

- Requests made before the debugger is attached will get canceled by pWebArc.
  So, for instance, when you middle-click a link, Chromium will open a new tab, but pWebArc will block the requests from there until the debugger gets attached and then automatically reload the tab after.
  As side-effect of this, Chromium will show "Request blocked" page until the debugger is attached and the page is reloaded, meaning it will get visually stuck on "Request blocked" page if fetching the request ended up spawning a download instead of showing a page.
  The download will proceed as normal, though.

- You will get an annoying notification bar constantly displayed in the browser while [[./popup.html#div-config.collecting][pWebArc is enabled]].
  Closing that notification will detach the debugger.
  pWebArc will reattach it immediately because it assumes you don't want to lose data and closing that notification on accident is, unfortunately, quite easy.

  *However, closing the notification will make all in-flight requests lose their response data.*

  If you [[./popup.html#div-config.collecting][disable pWebArc]] the debuggers will get detached only after all requests finish.
  But even if there are no requests in-flight the notification will not disappear immediately.
  Chromium takes its time updating the UI after the debugger is detached.

Moreover, Chromium has the following long-standing issues/bugs making things difficult:

- Chromium will automatically detach a debugger from a tab if it tries to save too much data into its debugger state.
  Which means that a tab that loads too much data too fast will get its debugger detached.
  Chromium does this to try and save memory, but this, among other issues, means that large images will fail to be properly archived, and any page that loads such files is likely to fail to be archived too.

  This is a design limitation of Chromium debugging interface, there appears to be no work-around for this at the moment.

  Meanwhile, on Firefox, pWebArc uses =webRequest.filterResponseData= API (not available no Chromium, because it greatly enhances browser's ad-blocking capabilities) which does not suffer from this problem.

- Chromium will occasionally detach debuggers from some tabs at random.
  It just happens.
  Fortunately, pWebArc will mark the resulting broken reqres as [[#problematic][problematic]] by default as they match the conditions of at least one of [[./popup.html#div-config.markProblematicNoResponse][this]], [[./popup.html#div-config.markProblematicIncomplete][this]], or [[./popup.html#div-config.markProblematicPickedWithErrors][that]] options.

- Chromium handling of media files (audio and video) within its debugging interface is very strange.
  When Chromium encounters a media file, it immediately loads a first few frames of it, then cancels the rest of the download, generates a networking error debugging event, but forgets to give the already loaded data to it, and then, when the user clicks the play button, continues the download by requesting the rest of the file as normal.
  Thus, on Chromium, for media files pWebArc will only ever get "206 Partial Content" HTTP responses with the first few kilobytes of file data missing.
  This bug has no good workaround, all alternatives to pWebArc that work with Chromium work it around by silently re-downloading the file the second time in background.

- Similarly to unpatched Firefox, Chromium-based browsers do not supply contents of files in POST request data.
  They do, however, provide a way to see if files were present in the request, so pWebArc will mark such and only such requests as having a "partial request body".
  There is no patch for Chromium to fix this, nor does the author plan to make one (feel free to contribute one, though).

  As with Firefox, disabling [[./popup.html#div-config.archivePartialRequest][this toggle]] will disable archiving of such broken requests.
  This is not recommended, however, as archiving some data is usually better than archiving none.

- If the server supplies the same header multiple times (which happens sometimes, most commonly with =Set-Cookie=) then archived response headers will either be weird (with multiple headers squished into a single value, separated by a newline symbol) or incomplete, as Chromium's =Network.responseReceived= debugging API event provides a dictionary of headers, not a list.

- Chromium fails to provide =openerTabId= to tabs created with =chrome.tabs.create= API so in the unlikely case of opening two or more new tabs/windows in rapid succession via pWebArc context menu actions and not giving them time to initialize pWebArc could end up mixing up settings between the newly created tabs/windows.
  This bug is impossible to trigger unless your system is very slow or you are clicking things with automation tools like =AutoHotKey= or =xnee=.

- To properly collect all the data about a reqres, pWebArc has to use both the data generated by =webRequest= API and Chromium's own debugging API events, using only one of those is usually insufficient.
  But Chromium generates different request IDs for events generated by these two different APIs and also generates those events in arbitrary order.
  Therefore, pWebArc tracks reqres generated by both sets of APIs separately and then matches those two lists against each other heuristically, merging matching reqres together.
  Which is ugly enough.
  But then Chromium sometimes generates debugging API events and forgets to produce the corresponding =webRequest= API events, or vice versa, thus leaving some of those reqres unmatched.
  To work around that, pWebArc waits [[./popup.html#div-config.workaroundChromiumDebugTimeout][this many seconds]] for new events to arrive, and if none do, forcefully finishes all unmatched in-flight reqres.
* Error messages and codes
:PROPERTIES:
:CUSTOM_ID: errors
:END:
** Desktop notifications
- =Failed to archive <N> items in the queue because pWebArc can't establish a connection to the archive at <URL>=

  Are you running the [[https://oxij.org/software/pwebarc/tree/master/dumb_server/][the archiving server script]]?
  pWebArc requires an archiving server to actually archive anything.

- =Failed to archive <N> items in the queue because requests to URL fail with: <STATUS> <REASON>: <RESPONSE>=

  Your archiving sever is returning HTTP errors when pWebArc is trying to archive data to it.
  See its error console for more information.

  Some common reasons it could be failing:
  - No space left on the device you are archiving to.
  - It's a bug.
** Errors recorded in =reqres=, as seen in the [[./popup.html#showState][log]]
Most error codes are produced by attaching one of the following prefixes to the raw error code given by the browser:

- =webRequest::= prefix is prepended to errors produced by the code working with =webRequest= API;

- =debugger::= prefix is prepended to errors produced by the code working with Chromium's Debugger API;

- =filterResponseData::= prefix is prepended to errors produced by =webRequest.filterResponseData= API (these can usually be ignored, since Firefox generates normal =webRequest::= codes for those reqres too, when it was an actual error, but pWebArc still collects them, adhering to "collect everything as browser gives it, when possible" philosophy).

In particular, =webRequest::NS_= prefix on Firefox, and =webRequest::net::= and =debugger::net::= prefixes on Chromium signify various issues produced by the networking stacks of those browsers.
For instance:

  - =webRequest::NS_ERROR_ABORT= on Firefox and =webRequest::net::ERR_ABORTED= on Chromium signify that this request was aborted before it finished, e.g. because the originator tab was closed before it was fully loaded;
    Firefox also uses this code to mean what Chromium signifies with various =BLOCKED= codes;

  - =webRequest::net::ERR_BLOCKED_BY_CLIENT= on Chromium signifies that an extension blocked it;

  - =debugger::net::ERR_BLOCKED::= is a prefix for other errors when the request was blocked, e.g. by CSP;

  - =webRequest::NS_ERROR_NET= prefix on Firefox and =webRequest::net::ERR_FAILED= error on Chromium signify various networking issues.

The exception to the above rule of keeping everything as raw as possible are =webRequest::pWebArc::= and =debugger::pWebArc::= prefixes which signify various errors produced by pWebArc itself in its =webRequest=- or =debugger=-handling code, respectively.
In particular:

- =webRequest::pWebArc::EMIT_FORCED_BY_USER= and =debugger::pWebArc::EMIT_FORCED_BY_USER= are produced when you forcefully advance a reqres from in-flight state by pressing [[./popup.html#stopAllTabInFlight][this]] or [[./popup.html#stopAllInFlight][that]] button;

- =debugger::pWebArc::EMIT_FORCED_BY_DETACHED_DEBUGGER= is produced when Chromium debugger gets detached from its tab while a reqres inside that tab is still in flight;

- =debugger::pWebArc::EMIT_FORCED_BY_CLOSED_TAB= is produced when a tab gets closed while a reqres inside of it is still in flight;

- =debugger::pWebArc::NO_RESPONSE_BODY::= is a prefix for errors produced when getting request's response body from Chromium's debugger fails for various reasons;

- =webRequest::pWebArc::NO_DEBUGGER::CANCELED= is produced when a non-main-frame request is canceled by pWebArc because no debugger is available to capture it;
  in the case of a main frame request, pWebArc will cancel the request and reload the tab, [[#chromium-bugs][as discussed above]], so this error will not be produced;
  but it can happen if a page tries to load a sub-frame (like =iframe=) while the debugger for the tab (and, thus, the main frame) did not attach yet (which only happens for pages where Chromium disallows debugging, or when pWebArc gets enabled after the page in question already started loading, e.g. the very first page after the browser starts);
  also, this can happen when the debugger gets detached after the main frame was captured but its resources are still loading.
* Frequently Asked Questions
:PROPERTIES:
:CUSTOM_ID: faq
:END:
** Does pWebArc send any of my captured web browsing data to any third-parties?
No.
pWebArc only ever sends data to the [[./popup.html#div-config.submitHTTPURLBase][archiving server URL]] you specify.
** Does pWebArc collect and send any telemetry anywhere?
No.
Note, however, that pWebArc does persist some global stat numbers across restarts --- e.g., [[./popup.html#div-stats.collected][Collected/Discarded reqres]] --- for convenience, but they are never sent anywhere, and [[./popup.html#resetPersistentStats][you can reset them]] at any time.
** Why do pages under [[https://addons.mozilla.org/]] and [[https://chromewebstore.google.com/]] can not be captured?
Browsers prevent extensions from running on extension store pages to prevent them from manipulating ratings, reviews, and etc such things.
However, you can archive [[https://addons.mozilla.org/]] pages by running pWebArc under Chromium and [[https://chromewebstore.google.com/]] pages by running pWebArc under Firefox.
** Why does a (specific) URL or some part of it fails to be properly captured?
Did you read the notes on [[#bugs][the bugs of the browser you are using]] above?

Most notably:

- both Chromium- and Firefox-based browsers in their default builds fail to properly supply POST request data to their extensions; for Firefox-based browsers there exists a [[#firefox-bugs][patch]] that fixes it, mostly; Chromium users are out of luck at the moment;

- on a Chromium-based browser, because of [[#chromium-bugs][limitations of the Chromium's debugging interface]], it is impossible to properly capture media files (both audio and video) and large files in general; this issue has no good work-around and, AFAIK, all alternatives to pWebArc running on Chromium-based browser suffer from it (and work around it by silently re-downloading said files the second time in background); try using pWebArc under a Firefox-based browser instead.
** On Chromium, a lot of my captures fail with =debugger::pWebArc::EMIT_FORCED_BY_DETACHED_DEBUGGER=, =debugger::pWebArc::NO_RESPONSE_BODY::DETACHED_DEBUGGER=, and =webRequest::pWebArc::NO_DEBUGGER::CANCELED= errors. What do I do?
:PROPERTIES:
:CUSTOM_ID: faq-debugger
:END:

You are either

- pressing the "Cancel" or "Close" (cross) buttons in the Chromium's popup-toolbar telling you about the debugger being enabled, and so Chromium detaches it, breaking everything ([[#chromium-bugs][see above]]);

- pressing =Space= or =Escape= keyboard keys when doing things in Chromium's UI, but nothing at that particular moment reacts to the key you pressed, except there is that popup-toolbar... and so Chromium decides it must mean you want to press "Cancel" button there ... and detaches the debugger, breaking everything ([[#chromium-bugs][again]]);

  yes, this is really annoying, and this is a common problem for me, since I usually page-down using =Space= and press =Escape= a lot (usually to cancel selection, but sometimes also as a trauma of a long-time Vim user);

  the only solution to this I know of is to just not touch the keyboard at all, at least while things are still loading;
  i.e. just click on stuff using the mouse/track-point/touch-pad/touchscreen/etc, wait for the "T" ("Tracking") to vanish from the extension's badge, and only then let your (grabby and impatient for exercise via keyboard shortcuts) fingers to touch the keyboard;

  even then, Chromium will detach debuggers from time to time seemingly at random, but at least it will be rare enough that you won't need to reload much;

- trying to capture large or media files; [[#chromium-bugs][as discussed above]], this has no workaround, run pWebArc under Firefox instead.
** Can I capture a web page without archiving it, look at it, decide if I want to save it, and archive it only if I do, all without reloading the page a second time?
:PROPERTIES:
:CUSTOM_ID: faq-limbo
:END:

Yes. This is why [[./popup.html#div-tabconfig.limbo]["Pick into limbo" setting]] exists.
See [[#limbo][above]] for more info.

In combination with [[./popup.html#closed-auto-options]["Automatic actions for recently closed tabs" options]] you can implement any of the following workflows:

- archive everything by default, but allow to exclude some things by manually discarding them from limbo;
- only archive things that are explicitly manually collected, discard everything else by default.
** Can I capture a web page/tab/frame as it currently is, after all JavaScript was run, not as it was when it was last fetched from the network?
:PROPERTIES:
:CUSTOM_ID: faq-snapshot
:END:

Yes, you can capture DOM (Document Object Model) snapshots for the currently active tab by pressing [[./popup.html#snapshotTab][this button]] in the popup.

Doing that will generate and capture snapshots of raw HTML/XMLs for each frame contained in the currently active tab.
(Reqres-wise they will be "200 OK" responses, but with =protocol= set to ="SNAPSHOT"= and =method= set to ="DOM"=.)

You can also do that for all open tabs at once by pressing [[./popup.html#snapshotAll][that button]].
** How do I properly archive a web page completely, especially when parts of it are loaded lazily?
:PROPERTIES:
:CUSTOM_ID: faq-lazy
:END:

In the most general case, you will have to scroll the page around and click random buttons and media elements.

pWebArc has no "autopilot" for doing this, nor will it ever get one, at least as part of pWebArc extension, since "autopiloting" is very website-specific.
So, at the moment, the most general semi-automated solution is to run a website-specific UserScript via [[https://addons.mozilla.org/en-US/firefox/addon/tampermonkey/][Tampermonkey]] or some such, wait until everything finishes loading, and then take a [[./popup.html#snapshotTab][snapshot]].
(pWebArc will get an integration for automating that, eventually.)

On the other hand, if you

- run pWebArc under Firefox,
- just want to load all lazily-loaded images the page already has (NOT load more stuff), and
- the page in question uses modern HTML5 lazy loading attributes instead of using JavaScript to do the same,

then you can simply go to =about:config= and toggle =dom.image-lazy-loading.enabled= to =false=.
All images will start being loaded eagerly after that.
** This page does not answer my question. What do I do?
If the whole content of this page (not just this section, did you try searching for stuff with =Control+F=? there's a lot of info here) does not explain your problem, [[https://github.com/Own-Data-Privateer/pwebarc/issues][open an issue on GitHub]] or [[https://oxij.org/#contact][get in touch otherwise]].
